
++ File:".\\tests\\TPDB\\XML_version\\TRS_Standard\\CiME_04\\tree.xml" :
TRS {trsSignature = fromList [("#",0),("+",2),("-",2),("0",1),("1",1),("and",2),("bs",1),("false",0),("ge",2),("if",3),("l",1),("max",1),("min",1),("n",3),("not",1),("size",1),("true",0),("val",1),("wb",1)], trsVariables = fromList ["x","y","z"], trsRMap = [], trsRules = [0(#) -> #,+(x,#) -> x,+(#,x) -> x,+(0(x),0(y)) -> 0(+(x,y)),+(0(x),1(y)) -> 1(+(x,y)),+(1(x),0(y)) -> 1(+(x,y)),+(1(x),1(y)) -> 0(+(+(x,y),1(#))),+(x,+(y,z)) -> +(+(x,y),z),-(x,#) -> x,-(#,x) -> #,-(0(x),0(y)) -> 0(-(x,y)),-(0(x),1(y)) -> 1(-(-(x,y),1(#))),-(1(x),0(y)) -> 1(-(x,y)),-(1(x),1(y)) -> 0(-(x,y)),not(false) -> true,not(true) -> false,and(x,true) -> x,and(x,false) -> false,if(true,x,y) -> x,if(false,x,y) -> y,ge(0(x),0(y)) -> ge(x,y),ge(0(x),1(y)) -> not(ge(y,x)),ge(1(x),0(y)) -> ge(x,y),ge(1(x),1(y)) -> ge(x,y),ge(x,#) -> true,ge(#,1(x)) -> false,ge(#,0(x)) -> ge(#,x),val(l(x)) -> x,val(n(x,y,z)) -> x,min(l(x)) -> x,min(n(x,y,z)) -> min(y),max(l(x)) -> x,max(n(x,y,z)) -> max(z),bs(l(x)) -> true,bs(n(x,y,z)) -> and(and(ge(x,max(y)),ge(min(z),x)),and(bs(y),bs(z))),size(l(x)) -> 1(#),size(n(x,y,z)) -> +(+(size(x),size(y)),1(#)),wb(l(x)) -> true,wb(n(x,y,z)) -> and(if(ge(size(y),size(z)),ge(1(#),-(size(y),size(z))),ge(1(#),-(size(z),size(y)))),and(wb(y),wb(z)))], trsType = TRSContextSensitive, trsStrategy = Just FULL, signatureBlock = True}

++ File:".\\tests\\TPDB\\XML_version\\TRS_Standard\\CiME_04\\ternary.xml" :
TRS {trsSignature = fromList [("#",0),("*",2),("+",2),("-",2),("0",1),("1",1),("j",1),("opp",1)], trsVariables = fromList ["x","y","z"], trsRMap = [], trsRules = [0(#) -> #,+(#,x) -> x,+(x,#) -> x,+(0(x),0(y)) -> 0(+(x,y)),+(0(x),1(y)) -> 1(+(x,y)),+(1(x),0(y)) -> 1(+(x,y)),+(0(x),j(y)) -> j(+(x,y)),+(j(x),0(y)) -> j(+(x,y)),+(1(x),1(y)) -> j(+(+(x,y),1(#))),+(j(x),j(y)) -> 1(+(+(x,y),j(#))),+(1(x),j(y)) -> 0(+(x,y)),+(j(x),1(y)) -> 0(+(x,y)),+(+(x,y),z) -> +(x,+(y,z)),opp(#) -> #,opp(0(x)) -> 0(opp(x)),opp(1(x)) -> j(opp(x)),opp(j(x)) -> 1(opp(x)),-(x,y) -> +(x,opp(y)),*(#,x) -> #,*(0(x),y) -> 0(*(x,y)),*(1(x),y) -> +(0(*(x,y)),y),*(j(x),y) -> -(0(*(x,y)),y),*(*(x,y),z) -> *(x,*(y,z))], trsType = TRSContextSensitive, trsStrategy = Just FULL, signatureBlock = True}

++ File:".\\tests\\TPDB\\XML_version\\TRS_Standard\\CiME_04\\ternary-hard.xml" :
TRS {trsSignature = fromList [("#",0),("*",2),("+",2),("-",2),("0",1),("1",1),("j",1),("opp",1)], trsVariables = fromList ["x","y","z"], trsRMap = [], trsRules = [0(#) -> #,+(#,x) -> x,+(x,#) -> x,+(0(x),0(y)) -> 0(+(x,y)),+(0(x),1(y)) -> 1(+(x,y)),+(1(x),0(y)) -> 1(+(x,y)),+(0(x),j(y)) -> j(+(x,y)),+(j(x),0(y)) -> j(+(x,y)),+(1(x),1(y)) -> j(+(+(x,y),1(#))),+(j(x),j(y)) -> 1(+(+(x,y),j(#))),+(1(x),j(y)) -> 0(+(x,y)),+(j(x),1(y)) -> 0(+(x,y)),+(+(x,y),z) -> +(x,+(y,z)),opp(#) -> #,opp(0(x)) -> 0(opp(x)),opp(1(x)) -> j(opp(x)),opp(j(x)) -> 1(opp(x)),-(x,y) -> +(x,opp(y)),*(#,x) -> #,*(0(x),y) -> 0(*(x,y)),*(1(x),y) -> +(0(*(x,y)),y),*(j(x),y) -> -(0(*(x,y)),y),*(*(x,y),z) -> *(x,*(y,z)),*(+(x,y),z) -> +(*(x,z),*(y,z)),*(x,+(y,z)) -> +(*(x,y),*(x,z))], trsType = TRSContextSensitive, trsStrategy = Just FULL, signatureBlock = True}

++ File:".\\tests\\TPDB\\XML_version\\TRS_Standard\\CiME_04\\mucrl1.xml" :
TRS {trsSignature = fromList [("0",0),("F",0),("T",0),("a",0),("and",2),("andt",2),("append",2),("calls",3),("case0",3),("case1",4),("case2",3),("case4",3),("case5",4),("case6",4),("case8",4),("case9",4),("cons",2),("delete",2),("element",2),("empty",0),("eq",2),("eqc",2),("eqs",2),("eqt",2),("equal",2),("excl",0),("excllock",0),("false",0),("gen_modtageq",2),("gen_tag",1),("if",3),("imp",2),("int",1),("istops",2),("lock",0),("locker",0),("locker2_add_pending",3),("locker2_adduniq",2),("locker2_check_available",2),("locker2_check_availables",2),("locker2_claim_lock",3),("locker2_map_add_pending",3),("locker2_map_claim_lock",3),("locker2_map_promote_pending",2),("locker2_obtainable",2),("locker2_obtainables",2),("locker2_promote_pending",2),("locker2_release_lock",2),("locker2_remove_pending",2),("mcrlrecord",0),("member",2),("nil",0),("nocalls",0),("not",1),("ok",0),("or",2),("pending",0),("pid",1),("pops",1),("push",3),("push1",6),("pushs",2),("record_extract",3),("record_new",1),("record_update",4),("record_updates",3),("release",0),("request",0),("resource",0),("s",1),("stack",2),("subtract",2),("tag",0),("tops",1),("true",0),("tuple",2),("tuplenil",1),("undefined",0)], trsVariables = fromList ["B","B1","B2","CS1","CS2","Client","Client1","Client2","E","E1","E2","E3","F0","F1","F2","Field","Fields","H1","H2","Head","List","Lock","Locks","MCRLFree0","MCRLFree1","N1","N2","Name","NewF","Pending","Pendings","Pid","Record","Resource","Resources","S1","S2","T1","T2","Tail"], trsRMap = [], trsRules = [or(T,T) -> T,or(F,T) -> T,or(T,F) -> T,or(F,F) -> F,and(T,B) -> B,and(B,T) -> B,and(F,B) -> F,and(B,F) -> F,imp(T,B) -> B,imp(F,B) -> T,not(T) -> F,not(F) -> T,if(T,B1,B2) -> B1,if(F,B1,B2) -> B2,eq(T,T) -> T,eq(F,F) -> T,eq(T,F) -> F,eq(F,T) -> F,eqt(nil,undefined) -> F,eqt(nil,pid(N2)) -> F,eqt(nil,int(N2)) -> F,eqt(nil,cons(H2,T2)) -> F,eqt(nil,tuple(H2,T2)) -> F,eqt(nil,tuplenil(H2)) -> F,eqt(a,nil) -> F,eqt(a,a) -> T,eqt(a,excl) -> F,eqt(a,false) -> F,eqt(a,lock) -> F,eqt(a,locker) -> F,eqt(a,mcrlrecord) -> F,eqt(a,ok) -> F,eqt(a,pending) -> F,eqt(a,release) -> F,eqt(a,request) -> F,eqt(a,resource) -> F,eqt(a,tag) -> F,eqt(a,true) -> F,eqt(a,undefined) -> F,eqt(a,pid(N2)) -> F,eqt(a,int(N2)) -> F,eqt(a,cons(H2,T2)) -> F,eqt(a,tuple(H2,T2)) -> F,eqt(a,tuplenil(H2)) -> F,eqt(excl,nil) -> F,eqt(excl,a) -> F,eqt(excl,excl) -> T,eqt(excl,false) -> F,eqt(excl,lock) -> F,eqt(excl,locker) -> F,eqt(excl,mcrlrecord) -> F,eqt(excl,ok) -> F,eqt(excl,pending) -> F,eqt(excl,release) -> F,eqt(excl,request) -> F,eqt(excl,resource) -> F,eqt(excl,tag) -> F,eqt(excl,true) -> F,eqt(excl,undefined) -> F,eqt(excl,pid(N2)) -> F,eqt(excl,eqt(false,int(N2))) -> F,eqt(false,cons(H2,T2)) -> F,eqt(false,tuple(H2,T2)) -> F,eqt(false,tuplenil(H2)) -> F,eqt(lock,nil) -> F,eqt(lock,a) -> F,eqt(lock,excl) -> F,eqt(lock,false) -> F,eqt(lock,lock) -> T,eqt(lock,locker) -> F,eqt(lock,mcrlrecord) -> F,eqt(lock,ok) -> F,eqt(lock,pending) -> F,eqt(lock,release) -> F,eqt(lock,request) -> F,eqt(lock,resource) -> F,eqt(lock,tag) -> F,eqt(lock,true) -> F,eqt(lock,undefined) -> F,eqt(lock,pid(N2)) -> F,eqt(lock,int(N2)) -> F,eqt(lock,cons(H2,T2)) -> F,eqt(lock,tuple(H2,T2)) -> F,eqt(lock,tuplenil(H2)) -> F,eqt(locker,nil) -> F,eqt(locker,a) -> F,eqt(locker,excl) -> F,eqt(locker,false) -> F,eqt(locker,lock) -> F,eqt(locker,locker) -> T,eqt(locker,mcrlrecord) -> F,eqt(locker,ok) -> F,eqt(locker,pending) -> F,eqt(locker,release) -> F,eqt(locker,request) -> F,eqt(locker,resource) -> F,eqt(locker,tag) -> F,eqt(locker,true) -> F,eqt(locker,undefined) -> F,eqt(locker,pid(N2)) -> F,eqt(locker,int(N2)) -> F,eqt(locker,cons(H2,T2)) -> F,eqt(locker,tuple(H2,T2)) -> F,eqt(locker,tuplenil(H2)) -> F,eqt(mcrlrecord,nil) -> F,eqt(mcrlrecord,a) -> F,eqt(mcrlrecord,excl) -> F,eqt(mcrlrecord,false) -> F,eqt(mcrlrecord,lock) -> F,eqt(mcrlrecord,locker) -> F,eqt(mcrlrecord,mcrlrecord) -> T,eqt(mcrlrecord,ok) -> F,eqt(mcrlrecord,pending) -> F,eqt(mcrlrecord,release) -> F,eqt(mcrlrecord,request) -> F,eqt(mcrlrecord,resource) -> F,eqt(ok,resource) -> F,eqt(ok,tag) -> F,eqt(ok,true) -> F,eqt(ok,undefined) -> F,eqt(ok,pid(N2)) -> F,eqt(ok,int(N2)) -> F,eqt(ok,cons(H2,T2)) -> F,eqt(ok,tuple(H2,T2)) -> F,eqt(ok,tuplenil(H2)) -> F,eqt(pending,nil) -> F,eqt(pending,a) -> F,eqt(pending,excl) -> F,eqt(pending,false) -> F,eqt(pending,lock) -> F,eqt(pending,locker) -> F,eqt(pending,mcrlrecord) -> F,eqt(pending,ok) -> F,eqt(pending,pending) -> T,eqt(pending,release) -> F,eqt(pending,request) -> F,eqt(pending,resource) -> F,eqt(pending,tag) -> F,eqt(pending,true) -> F,eqt(pending,undefined) -> F,eqt(pending,pid(N2)) -> F,eqt(pending,int(N2)) -> F,eqt(pending,cons(H2,T2)) -> F,eqt(pending,tuple(H2,T2)) -> F,eqt(pending,tuplenil(H2)) -> F,eqt(release,nil) -> F,eqt(release,a) -> F,eqt(release,excl) -> F,eqt(release,false) -> F,eqt(release,lock) -> F,eqt(release,locker) -> F,eqt(release,mcrlrecord) -> F,eqt(release,ok) -> F,eqt(request,mcrlrecord) -> F,eqt(request,ok) -> F,eqt(request,pending) -> F,eqt(request,release) -> F,eqt(request,request) -> T,eqt(request,resource) -> F,eqt(request,tag) -> F,eqt(request,true) -> F,eqt(request,undefined) -> F,eqt(request,pid(N2)) -> F,eqt(request,int(N2)) -> F,eqt(request,cons(H2,T2)) -> F,eqt(request,tuple(H2,T2)) -> F,eqt(request,tuplenil(H2)) -> F,eqt(resource,nil) -> F,eqt(resource,a) -> F,eqt(resource,excl) -> F,eqt(resource,false) -> F,eqt(resource,lock) -> F,eqt(resource,locker) -> F,eqt(resource,mcrlrecord) -> F,eqt(resource,ok) -> F,eqt(resource,pending) -> F,eqt(resource,release) -> F,eqt(resource,request) -> F,eqt(resource,resource) -> T,eqt(resource,tag) -> F,eqt(resource,true) -> F,eqt(resource,undefined) -> F,eqt(resource,pid(N2)) -> F,eqt(resource,int(N2)) -> F,eqt(resource,cons(H2,T2)) -> F,eqt(resource,tuple(H2,T2)) -> F,eqt(resource,tuplenil(H2)) -> F,eqt(tag,nil) -> F,eqt(tag,a) -> F,eqt(tag,excl) -> F,eqt(tag,false) -> F,eqt(tag,lock) -> F,eqt(tag,locker) -> F,eqt(tag,mcrlrecord) -> F,eqt(tag,ok) -> F,eqt(tag,pending) -> F,eqt(tag,release) -> F,eqt(tag,request) -> F,eqt(tag,resource) -> F,eqt(tag,tag) -> T,eqt(tag,true) -> F,eqt(tag,undefined) -> F,eqt(tag,pid(N2)) -> F,eqt(tag,int(N2)) -> F,eqt(tag,cons(H2,T2)) -> F,eqt(tag,tuple(H2,T2)) -> F,eqt(tag,tuplenil(H2)) -> F,eqt(true,nil) -> F,eqt(true,a) -> F,eqt(true,excl) -> F,eqt(true,false) -> F,eqt(true,lock) -> F,eqt(true,locker) -> F,eqt(true,mcrlrecord) -> F,eqt(true,ok) -> F,eqt(true,pending) -> F,eqt(true,release) -> F,eqt(true,request) -> F,eqt(true,resource) -> F,eqt(true,tag) -> F,eqt(true,true) -> T,eqt(true,undefined) -> F,eqt(true,pid(N2)) -> F,eqt(true,int(N2)) -> F,eqt(true,cons(H2,T2)) -> F,eqt(true,tuple(H2,T2)) -> F,eqt(true,tuplenil(H2)) -> F,eqt(undefined,nil) -> F,eqt(undefined,a) -> F,eqt(undefined,tuplenil(H2)) -> F,eqt(pid(N1),nil) -> F,eqt(pid(N1),a) -> F,eqt(pid(N1),excl) -> F,eqt(pid(N1),false) -> F,eqt(pid(N1),lock) -> F,eqt(pid(N1),locker) -> F,eqt(pid(N1),mcrlrecord) -> F,eqt(pid(N1),ok) -> F,eqt(pid(N1),pending) -> F,eqt(pid(N1),release) -> F,eqt(pid(N1),request) -> F,eqt(pid(N1),resource) -> F,eqt(pid(N1),tag) -> F,eqt(pid(N1),true) -> F,eqt(pid(N1),undefined) -> F,eqt(pid(N1),pid(N2)) -> eqt(N1,N2),eqt(pid(N1),int(N2)) -> F,eqt(pid(N1),cons(H2,T2)) -> F,eqt(pid(N1),tuple(H2,T2)) -> F,eqt(pid(N1),tuplenil(H2)) -> F,eqt(int(N1),nil) -> F,eqt(int(N1),a) -> F,eqt(int(N1),excl) -> F,eqt(int(N1),false) -> F,eqt(int(N1),lock) -> F,eqt(int(N1),locker) -> F,eqt(int(N1),mcrlrecord) -> F,eqt(int(N1),ok) -> F,eqt(int(N1),pending) -> F,eqt(int(N1),release) -> F,eqt(int(N1),request) -> F,eqt(int(N1),resource) -> F,eqt(int(N1),tag) -> F,eqt(int(N1),true) -> F,eqt(int(N1),undefined) -> F,eqt(cons(H1,T1),resource) -> F,eqt(cons(H1,T1),tag) -> F,eqt(cons(H1,T1),true) -> F,eqt(cons(H1,T1),undefined) -> F,eqt(cons(H1,T1),pid(N2)) -> F,eqt(cons(H1,T1),int(N2)) -> F,eqt(cons(H1,T1),cons(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2)),eqt(cons(H1,T1),tuple(H2,T2)) -> F,eqt(cons(H1,T1),tuplenil(H2)) -> F,eqt(tuple(H1,T1),nil) -> F,eqt(tuple(H1,T1),a) -> F,eqt(tuple(H1,T1),excl) -> F,eqt(tuple(H1,T1),false) -> F,eqt(tuple(H1,T1),lock) -> F,eqt(tuple(H1,T1),locker) -> F,eqt(tuple(H1,T1),mcrlrecord) -> F,eqt(tuple(H1,T1),ok) -> F,eqt(tuple(H1,T1),pending) -> F,eqt(tuple(H1,T1),release) -> F,eqt(tuple(H1,T1),request) -> F,eqt(tuple(H1,T1),resource) -> F,eqt(tuple(H1,T1),tag) -> F,eqt(tuple(H1,T1),true) -> F,eqt(tuple(H1,T1),undefined) -> F,eqt(tuple(H1,T1),pid(N2)) -> F,eqt(tuple(H1,T1),int(N2)) -> F,eqt(tuple(H1,T1),cons(H2,T2)) -> F,eqt(tuple(H1,T1),tuple(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2)),eqt(tuple(H1,T1),tuplenil(H2)) -> F,eqt(tuplenil(H1),nil) -> F,eqt(tuplenil(H1),a) -> F,eqt(tuplenil(H1),excl) -> F,eqt(tuplenil(H1),false) -> F,eqt(tuplenil(H1),lock) -> F,eqt(tuplenil(H1),locker) -> F,eqt(tuplenil(H1),mcrlrecord) -> F,eqt(tuplenil(H1),ok) -> F,eqt(tuplenil(H1),pending) -> F,eqt(tuplenil(H1),release) -> F,eqt(tuplenil(H1),request) -> F,eqt(tuplenil(H1),resource) -> F,eqt(tuplenil(H1),tag) -> F,eqt(tuplenil(H1),true) -> F,eqt(tuplenil(H1),undefined) -> F,eqt(tuplenil(H1),pid(N2)) -> F,eqt(tuplenil(H1),int(N2)) -> F,eqt(tuplenil(H1),cons(H2,T2)) -> F,eqt(tuplenil(H1),tuple(H2,T2)) -> F,eqt(tuplenil(H1),tuplenil(H2)) -> eqt(H1,H2),element(int(s(0)),tuplenil(T1)) -> T1,element(int(s(0)),tuple(T1,T2)) -> T1,element(int(s(s(N1))),tuple(T1,T2)) -> element(int(s(N1)),T2),record_new(lock) -> tuple(mcrlrecord,tuple(lock,tuple(undefined,tuple(nil,tuplenil(nil))))),record_extract(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,resource) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),record_update(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,pending,NewF) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(NewF))))),record_updates(Record,Name,nil) -> Record,record_updates(Record,Name,cons(tuple(Field,tuplenil(NewF)),Fields)) -> record_updates(record_update(Record,Name,Field,NewF),Name,Fields),locker2_map_promote_pending(nil,Pending) -> nil,locker2_map_promote_pending(cons(Lock,Locks),Pending) -> cons(locker2_promote_pending(Lock,Pending),locker2_map_promote_pending(Locks,Pending)),locker2_map_claim_lock(nil,Resources,Client) -> nil,locker2_map_claim_lock(cons(Lock,Locks),Resources,Client) -> cons(locker2_claim_lock(Lock,Resources,Client),locker2_map_claim_lock(Locks,Resources,Client)),locker2_map_add_pending(nil,Resources,Client) -> nil,locker2_promote_pending(Lock,Client) -> case0(Client,Lock,record_extract(Lock,lock,pending)),case0(Client,Lock,cons(Client,Pendings)) -> record_updates(Lock,lock,cons(tuple(excl,tuplenil(Client)),cons(tuple(pending,tuplenil(Pendings)),nil))),case0(Client,Lock,MCRLFree0) -> Lock,locker2_remove_pending(Lock,Client) -> record_updates(Lock,lock,cons(tuple(pending,tuplenil(subtract(record_extract(Lock,lock,pending),cons(Client,nil)))),nil)),locker2_add_pending(Lock,Resources,Client) -> case1(Client,Resources,Lock,member(record_extract(Lock,lock,resource),Resources)),case1(Client,Resources,Lock,true) -> record_updates(Lock,lock,cons(tuple(pending,tuplenil(append(record_extract(Lock,lock,pending),cons(Client,nil)))),nil)),case1(Client,Resources,Lock,false) -> Lock,locker2_release_lock(Lock,Client) -> case2(Client,Lock,gen_modtageq(Client,record_extract(Lock,lock,excl))),case2(Client,Lock,true) -> record_updates(Lock,lock,cons(tuple(excllock,excl),nil)),case4(Client,Lock,MCRLFree1) -> false,locker2_obtainables(nil,Client) -> true,locker2_obtainables(cons(Lock,Locks),Client) -> case5(Client,Locks,Lock,member(Client,record_extract(Lock,lock,pending))),case5(Client,Locks,Lock,true) -> andt(locker2_obtainable(Lock,Client),locker2_obtainables(Locks,Client)),case5(Client,Locks,Lock,false) -> locker2_obtainables(Locks,Client),locker2_check_available(Resource,nil) -> false,locker2_check_available(Resource,cons(Lock,Locks)) -> case6(Locks,Lock,Resource,equal(Resource,record_extract(Lock,lock,resource))),case6(Locks,Lock,Resource,true) -> andt(equal(record_extract(Lock,lock,excl),nil),equal(record_extract(Lock,lock,pending),nil)),case6(Locks,Lock,Resource,false) -> locker2_check_available(Resource,Locks),locker2_check_availables(nil,Locks) -> true,locker2_check_availables(cons(Resource,Resources),Locks) -> andt(locker2_check_available(Resource,Locks),locker2_check_availables(Resources,Locks)),locker2_adduniq(nil,List) -> List,append(cons(Head,Tail),List) -> cons(Head,append(Tail,List)),subtract(List,nil) -> List,subtract(List,cons(Head,Tail)) -> subtract(delete(Head,List),Tail),delete(E,nil) -> nil,delete(E,cons(Head,Tail)) -> case8(Tail,Head,E,equal(E,Head)),case8(Tail,Head,E,true) -> Tail,case8(Tail,Head,E,false) -> cons(Head,delete(E,Tail)),gen_tag(Pid) -> tuple(Pid,tuplenil(tag)),gen_modtageq(Client1,Client2) -> equal(Client1,Client2),member(E,nil) -> false,member(E,cons(Head,Tail)) -> case9(Tail,Head,E,equal(E,Head)),case9(Tail,Head,E,true) -> true,case9(Tail,Head,E,false) -> member(E,Tail),eqs(empty,empty) -> T,eqs(empty,stack(E2,S2)) -> F,eqs(stack(E1,S1),empty) -> F,eqs(stack(E1,S1),stack(E2,S2)) -> and(eqt(E1,E2),eqs(S1,S2)),pushs(E1,S1) -> stack(E1,S1),pops(stack(E1,S1)) -> S1,tops(stack(E1,S1)) -> E1,istops(E1,empty) -> F,istops(E1,stack(E2,S1)) -> eqt(E1,E2),eqc(nocalls,nocalls) -> T,eqc(nocalls,calls(E2,S2,CS2)) -> F,eqc(calls(E1,S1,CS1),nocalls) -> F,eqc(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> and(eqt(E1,E2),and(eqs(S1,S2),eqc(CS1,CS2))),push(E1,E2,nocalls) -> calls(E1,stack(E2,empty),nocalls),push(E1,E2,calls(E3,S1,CS1)) -> push1(E1,E2,E3,S1,CS1,eqt(E1,E3)),push1(E1,E2,E3,S1,CS1,T) -> calls(E3,pushs(E2,S1),CS1)], trsType = TRSContextSensitive, trsStrategy = Just FULL, signatureBlock = True}

++ File:".\\tests\\TPDB\\XML_version\\TRS_Standard\\CiME_04\\maude2.xml" :
TRS {trsSignature = fromList [("*",2),("+",2),("0",0),("False",0),("True",0),("d",2),("gcd",2),("gt",2),("is_NzNat",1),("lt",2),("p",1),("quot",2),("s",1),("u_01",1),("u_02",2),("u_1",3),("u_11",3),("u_2",1),("u_21",3),("u_3",3),("u_31",4),("u_4",1)], trsVariables = fromList ["M","N","NzM","NzN"], trsRMap = [], trsRules = [p(s(N)) -> N,+(N,0) -> N,+(s(N),s(M)) -> s(s(+(N,M))),*(N,0) -> 0,*(s(N),s(M)) -> s(+(N,+(M,*(N,M)))),gt(0,M) -> False,gt(NzN,0) -> u_4(is_NzNat(NzN)),u_4(True) -> True,is_NzNat(0) -> False,is_NzNat(s(N)) -> True,gt(s(N),s(M)) -> gt(N,M),lt(N,M) -> gt(M,N),d(0,N) -> N,d(s(N),s(M)) -> d(N,M),quot(N,NzM) -> u_11(is_NzNat(NzM),N,NzM),u_11(True,N,NzM) -> u_1(gt(N,NzM),N,NzM),u_1(True,N,NzM) -> s(quot(d(N,NzM),NzM)),quot(NzM,NzM) -> u_01(is_NzNat(NzM)),u_01(True) -> s(0),quot(N,NzM) -> u_21(is_NzNat(NzM),NzM,N),u_21(True,NzM,N) -> u_2(gt(NzM,N)),u_2(True) -> 0,gcd(0,N) -> 0,gcd(NzM,NzM) -> u_02(is_NzNat(NzM),NzM),u_02(True,NzM) -> NzM,gcd(NzN,NzM) -> u_31(is_NzNat(NzN),is_NzNat(NzM),NzN,NzM),u_31(True,True,NzN,NzM) -> u_3(gt(NzN,NzM),NzN,NzM),u_3(True,NzN,NzM) -> gcd(d(NzN,NzM),NzM)], trsType = TRSContextSensitive, trsStrategy = Just FULL, signatureBlock = True}

++ File:".\\tests\\TPDB\\XML_version\\TRS_Standard\\CiME_04\\lse.xml" :
TRS {trsSignature = fromList [("Case",3),("Concat",2),("Cons_sum",3),("Cons_usual",3),("Frozen",4),("Id",0),("Left",0),("Right",0),("Sum_constant",1),("Sum_sub",2),("Sum_term_var",1),("Term_app",2),("Term_inl",1),("Term_inr",1),("Term_pair",2),("Term_sub",2),("Term_var",1)], trsVariables = fromList ["k","m","n","psi","s","t","u","x","xi","y"], trsRMap = [], trsRules = [Term_sub(Case(m,xi,n),s) -> Frozen(m,Sum_sub(xi,s),n,s),Frozen(m,Sum_constant(Left),n,s) -> Term_sub(m,s),Frozen(m,Sum_constant(Right),n,s) -> Term_sub(n,s),Frozen(m,Sum_term_var(xi),n,s) -> Case(Term_sub(m,s),xi,Term_sub(n,s)),Term_sub(Term_app(m,n),s) -> Term_app(Term_sub(m,s),Term_sub(n,s)),Term_sub(Term_pair(m,n),s) -> Term_pair(Term_sub(m,s),Term_sub(n,s)),Term_sub(Term_inl(m),s) -> Term_inl(Term_sub(m,s)),Term_sub(Term_inr(m),s) -> Term_inr(Term_sub(m,s)),Term_sub(Term_var(x),Id) -> Term_var(x),Term_sub(Term_var(x),Cons_usual(y,m,s)) -> m,Term_sub(Term_var(x),Cons_usual(y,m,s)) -> Term_sub(Term_var(x),s),Term_sub(Term_var(x),Cons_sum(xi,k,s)) -> Term_sub(Term_var(x),s),Term_sub(Term_sub(m,s),t) -> Term_sub(m,Concat(s,t)),Sum_sub(xi,Id) -> Sum_term_var(xi),Sum_sub(xi,Cons_sum(psi,k,s)) -> Sum_constant(k),Sum_sub(xi,Cons_sum(psi,k,s)) -> Sum_sub(xi,s),Sum_sub(xi,Cons_usual(y,m,s)) -> Sum_sub(xi,s),Concat(Concat(s,t),u) -> Concat(s,Concat(t,u)),Concat(Cons_usual(x,m,s),t) -> Cons_usual(x,Term_sub(m,t),Concat(s,t)),Concat(Cons_sum(xi,k,s),t) -> Cons_sum(xi,k,Concat(s,t)),Concat(Id,s) -> s], trsType = TRSContextSensitive, trsStrategy = Just FULL, signatureBlock = True}

++ File:".\\tests\\TPDB\\XML_version\\TRS_Standard\\CiME_04\\log2.xml" :
TRS {trsSignature = fromList [("#",0),("+",2),("-",2),("0",1),("1",1),("false",0),("ge",2),("if",3),("log",1),("log'",1),("not",1),("true",0)], trsVariables = fromList ["x","y","z"], trsRMap = [], trsRules = [0(#) -> #,+(#,x) -> x,+(x,#) -> x,+(0(x),0(y)) -> 0(+(x,y)),+(0(x),1(y)) -> 1(+(x,y)),+(1(x),0(y)) -> 1(+(x,y)),+(1(x),1(y)) -> 0(+(+(x,y),1(#))),+(+(x,y),z) -> +(x,+(y,z)),-(#,x) -> #,-(x,#) -> x,-(0(x),0(y)) -> 0(-(x,y)),-(0(x),1(y)) -> 1(-(-(x,y),1(#))),-(1(x),0(y)) -> 1(-(x,y)),-(1(x),1(y)) -> 0(-(x,y)),not(true) -> false,not(false) -> true,if(true,x,y) -> x,if(false,x,y) -> y,ge(0(x),0(y)) -> ge(x,y),ge(0(x),1(y)) -> not(ge(y,x)),ge(1(x),0(y)) -> ge(x,y),ge(1(x),1(y)) -> ge(x,y),ge(x,#) -> true,ge(#,0(x)) -> ge(#,x),ge(#,1(x)) -> false,log(x) -> -(log'(x),1(#)),log'(#) -> #,log'(1(x)) -> +(log'(x),1(#)),log'(0(x)) -> if(ge(x,1(#)),+(log'(x),1(#)),#)], trsType = TRSContextSensitive, trsStrategy = Just FULL, signatureBlock = True}

++ File:".\\tests\\TPDB\\XML_version\\TRS_Standard\\CiME_04\\list-sum-prod.xml" :
TRS {trsSignature = fromList [("*",2),("+",2),("0",0),("cons",2),("nil",0),("prod",1),("s",1),("sum",1)], trsVariables = fromList ["l","x","y"], trsRMap = [], trsRules = [+(x,0) -> x,+(0,x) -> x,+(s(x),s(y)) -> s(s(+(x,y))),*(x,0) -> 0,*(0,x) -> 0,*(s(x),s(y)) -> s(+(*(x,y),+(x,y))),sum(nil) -> 0,sum(cons(x,l)) -> +(x,sum(l)),prod(nil) -> s(0),prod(cons(x,l)) -> *(x,prod(l))], trsType = TRSContextSensitive, trsStrategy = Just FULL, signatureBlock = True}

++ File:".\\tests\\TPDB\\XML_version\\TRS_Standard\\CiME_04\\list-sum-prod-bin.xml" :
TRS {trsSignature = fromList [("#",0),("*",2),("+",2),("0",1),("1",1),("cons",2),("nil",0),("prod",1),("sum",1)], trsVariables = fromList ["l","x","y"], trsRMap = [], trsRules = [0(#) -> #,+(x,#) -> x,+(#,x) -> x,+(0(x),0(y)) -> 0(+(x,y)),+(0(x),1(y)) -> 1(+(x,y)),+(1(x),0(y)) -> 1(+(x,y)),+(1(x),1(y)) -> 0(+(+(x,y),1(#))),*(#,x) -> #,*(0(x),y) -> 0(*(x,y)),*(1(x),y) -> +(0(*(x,y)),y),sum(nil) -> 0(#),sum(cons(x,l)) -> +(x,sum(l)),prod(nil) -> 1(#),prod(cons(x,l)) -> *(x,prod(l))], trsType = TRSContextSensitive, trsStrategy = Just FULL, signatureBlock = True}

++ File:".\\tests\\TPDB\\XML_version\\TRS_Standard\\CiME_04\\list-sum-prod-bin-assoc.xml" :
TRS {trsSignature = fromList [("#",0),("*",2),("+",2),("0",1),("1",1),("cons",2),("nil",0),("prod",1),("sum",1)], trsVariables = fromList ["l","x","y","z"], trsRMap = [], trsRules = [0(#) -> #,+(x,#) -> x,+(#,x) -> x,+(0(x),0(y)) -> 0(+(x,y)),+(0(x),1(y)) -> 1(+(x,y)),+(1(x),0(y)) -> 1(+(x,y)),+(1(x),1(y)) -> 0(+(+(x,y),1(#))),+(+(x,y),z) -> +(x,+(y,z)),*(#,x) -> #,*(0(x),y) -> 0(*(x,y)),*(1(x),y) -> +(0(*(x,y)),y),*(*(x,y),z) -> *(x,*(y,z)),sum(nil) -> 0(#),sum(cons(x,l)) -> +(x,sum(l)),prod(nil) -> 1(#),prod(cons(x,l)) -> *(x,prod(l))], trsType = TRSContextSensitive, trsStrategy = Just FULL, signatureBlock = True}

++ File:".\\tests\\TPDB\\XML_version\\TRS_Standard\\CiME_04\\list-sum-prod-bin-assoc-distr-app.xml" :
TRS {trsSignature = fromList [("#",0),("*",2),("+",2),("0",1),("1",1),("app",2),("cons",2),("nil",0),("prod",1),("sum",1)], trsVariables = fromList ["l","l1","l2","x","y","z"], trsRMap = [], trsRules = [0(#) -> #,+(x,#) -> x,+(#,x) -> x,+(0(x),0(y)) -> 0(+(x,y)),+(0(x),1(y)) -> 1(+(x,y)),+(1(x),0(y)) -> 1(+(x,y)),+(1(x),1(y)) -> 0(+(+(x,y),1(#))),+(+(x,y),z) -> +(x,+(y,z)),*(#,x) -> #,*(0(x),y) -> 0(*(x,y)),*(1(x),y) -> +(0(*(x,y)),y),*(*(x,y),z) -> *(x,*(y,z)),*(x,+(y,z)) -> +(*(x,y),*(x,z)),app(nil,l) -> l,app(cons(x,l1),l2) -> cons(x,app(l1,l2)),sum(nil) -> 0(#),sum(cons(x,l)) -> +(x,sum(l)),sum(app(l1,l2)) -> +(sum(l1),sum(l2)),prod(nil) -> 1(#),prod(cons(x,l)) -> *(x,prod(l)),prod(app(l1,l2)) -> *(prod(l1),prod(l2))], trsType = TRSContextSensitive, trsStrategy = Just FULL, signatureBlock = True}

++ File:".\\tests\\TPDB\\XML_version\\TRS_Standard\\CiME_04\\list-sum-prod-assoc.xml" :
TRS {trsSignature = fromList [("*",2),("+",2),("0",0),("cons",2),("nil",0),("prod",1),("s",1),("sum",1)], trsVariables = fromList ["l","x","y","z"], trsRMap = [], trsRules = [+(x,0) -> x,+(0,x) -> x,+(s(x),s(y)) -> s(s(+(x,y))),+(+(x,y),z) -> +(x,+(y,z)),*(x,0) -> 0,*(0,x) -> 0,*(s(x),s(y)) -> s(+(*(x,y),+(x,y))),*(*(x,y),z) -> *(x,*(y,z)),sum(nil) -> 0,sum(cons(x,l)) -> +(x,sum(l)),prod(nil) -> s(0),prod(cons(x,l)) -> *(x,prod(l))], trsType = TRSContextSensitive, trsStrategy = Just FULL, signatureBlock = True}

++ File:".\\tests\\TPDB\\XML_version\\TRS_Standard\\CiME_04\\list-sum-prod-assoc-append.xml" :
TRS {trsSignature = fromList [("*",2),("+",2),("0",0),("app",2),("cons",2),("nil",0),("prod",1),("s",1),("sum",1)], trsVariables = fromList ["l","l1","l2","x","y","z"], trsRMap = [], trsRules = [+(x,0) -> x,+(0,x) -> x,+(s(x),s(y)) -> s(s(+(x,y))),+(+(x,y),z) -> +(x,+(y,z)),*(x,0) -> 0,*(0,x) -> 0,*(s(x),s(y)) -> s(+(*(x,y),+(x,y))),*(*(x,y),z) -> *(x,*(y,z)),app(nil,l) -> l,app(cons(x,l1),l2) -> cons(x,app(l1,l2)),sum(nil) -> 0,sum(cons(x,l)) -> +(x,sum(l)),sum(app(l1,l2)) -> +(sum(l1),sum(l2)),prod(nil) -> s(0),prod(cons(x,l)) -> *(x,prod(l)),prod(app(l1,l2)) -> *(prod(l1),prod(l2))], trsType = TRSContextSensitive, trsStrategy = Just FULL, signatureBlock = True}

++ File:".\\tests\\TPDB\\XML_version\\TRS_Standard\\CiME_04\\intersect.xml" :
TRS {trsSignature = fromList [("0",0),("app",2),("cons",2),("eq",2),("false",0),("if",3),("ifinter",4),("ifmem",3),("inter",2),("mem",2),("nil",0),("s",1),("true",0)], trsVariables = fromList ["l","l1","l2","l3","x","y"], trsRMap = [], trsRules = [if(true,x,y) -> x,if(false,x,y) -> y,eq(0,0) -> true,eq(0,s(x)) -> false,eq(s(x),0) -> false,eq(s(x),s(y)) -> eq(x,y),app(nil,l) -> l,app(cons(x,l1),l2) -> cons(x,app(l1,l2)),app(app(l1,l2),l3) -> app(l1,app(l2,l3)),mem(x,nil) -> false,mem(x,cons(y,l)) -> ifmem(eq(x,y),x,l),ifmem(true,x,l) -> true,ifmem(false,x,l) -> mem(x,l),inter(x,nil) -> nil,inter(nil,x) -> nil,inter(app(l1,l2),l3) -> app(inter(l1,l3),inter(l2,l3)),inter(l1,app(l2,l3)) -> app(inter(l1,l2),inter(l1,l3)),inter(cons(x,l1),l2) -> ifinter(mem(x,l2),x,l1,l2),inter(l1,cons(x,l2)) -> ifinter(mem(x,l1),x,l2,l1),ifinter(true,x,l1,l2) -> cons(x,inter(l1,l2)),ifinter(false,x,l1,l2) -> inter(l1,l2)], trsType = TRSContextSensitive, trsStrategy = Just FULL, signatureBlock = True}

++ File:".\\tests\\TPDB\\XML_version\\TRS_Standard\\CiME_04\\fact-hard.xml" :
TRS {trsSignature = fromList [("*",2),("+",2),("-",2),("0",0),("fact",1),("false",0),("ge",2),("iffact",2),("s",1),("true",0)], trsVariables = fromList ["x","y"], trsRMap = [], trsRules = [+(x,0) -> x,+(x,s(y)) -> s(+(x,y)),*(x,0) -> 0,*(x,s(y)) -> +(*(x,y),x),ge(x,0) -> true,ge(0,s(y)) -> false,ge(s(x),s(y)) -> ge(x,y),-(x,0) -> x,-(s(x),s(y)) -> -(x,y),fact(x) -> iffact(x,ge(x,s(s(0)))),iffact(x,true) -> *(x,fact(-(x,s(0)))),iffact(x,false) -> s(0)], trsType = TRSContextSensitive, trsStrategy = Just FULL, signatureBlock = True}

++ File:".\\tests\\TPDB\\XML_version\\TRS_Standard\\CiME_04\\dpqs.xml" :
TRS {trsSignature = fromList [("0",0),("1",0),("c",1),("d",1),("f",1),("g",1)], trsVariables = fromList ["x"], trsRMap = [], trsRules = [f(f(x)) -> f(c(f(x))),f(f(x)) -> f(d(f(x))),g(c(x)) -> x,g(d(x)) -> x,g(c(0)) -> g(d(1)),g(c(1)) -> g(d(0))], trsType = TRSContextSensitive, trsStrategy = Just FULL, signatureBlock = True}

++ File:".\\tests\\TPDB\\XML_version\\TRS_Standard\\CiME_04\\boolean_rings.xml" :
TRS {trsSignature = fromList [("F",0),("T",0),("and",2),("equiv",2),("impl",2),("neg",1),("or",2),("xor",2)], trsVariables = fromList ["x","y","z"], trsRMap = [], trsRules = [xor(x,F) -> x,xor(x,neg(x)) -> F,and(x,T) -> x,and(x,F) -> F,and(x,x) -> x,and(xor(x,y),z) -> xor(and(x,z),and(y,z)),xor(x,x) -> F,impl(x,y) -> xor(and(x,y),xor(x,T)),or(x,y) -> xor(and(x,y),xor(x,y)),equiv(x,y) -> xor(x,xor(y,T)),neg(x) -> xor(x,T)], trsType = TRSContextSensitive, trsStrategy = Just FULL, signatureBlock = True}

++ File:".\\tests\\TPDB\\XML_version\\TRS_Standard\\CiME_04\\big.xml" :
TRS {trsSignature = fromList [("#",0),("*",2),("+",2),("-",2),("0",1),("1",1),("app",2),("cons",2),("eq",2),("false",0),("ge",2),("if",3),("ifinter",4),("inter",2),("log",1),("log'",1),("mem",2),("nil",0),("not",1),("prod",1),("sum",1),("true",0)], trsVariables = fromList ["l","l1","l2","l3","x","y","z"], trsRMap = [], trsRules = [0(#) -> #,+(x,#) -> x,+(#,x) -> x,+(0(x),0(y)) -> 0(+(x,y)),+(0(x),1(y)) -> 1(+(x,y)),+(1(x),0(y)) -> 1(+(x,y)),+(1(x),1(y)) -> 0(+(+(x,y),1(#))),+(+(x,y),z) -> +(x,+(y,z)),-(#,x) -> #,-(x,#) -> x,-(0(x),0(y)) -> 0(-(x,y)),-(0(x),1(y)) -> 1(-(-(x,y),1(#))),-(1(x),0(y)) -> 1(-(x,y)),-(1(x),1(y)) -> 0(-(x,y)),not(true) -> false,not(false) -> true,if(true,x,y) -> x,if(false,x,y) -> y,eq(#,#) -> true,eq(#,1(y)) -> false,eq(1(x),#) -> false,eq(#,0(y)) -> eq(#,y),eq(0(x),#) -> eq(x,#),eq(1(x),1(y)) -> eq(x,y),eq(0(x),1(y)) -> false,eq(1(x),0(y)) -> false,eq(0(x),0(y)) -> eq(x,y),ge(0(x),0(y)) -> ge(x,y),ge(0(x),1(y)) -> not(ge(y,x)),ge(1(x),0(y)) -> ge(x,y),ge(1(x),1(y)) -> ge(x,y),ge(x,#) -> true,ge(#,0(x)) -> ge(#,x),ge(#,1(x)) -> false,log(x) -> -(log'(x),1(#)),log'(#) -> #,log'(1(x)) -> +(log'(x),1(#)),log'(0(x)) -> if(ge(x,1(#)),+(log'(x),1(#)),#),*(#,x) -> #,*(0(x),y) -> 0(*(x,y)),*(1(x),y) -> +(0(*(x,y)),y),*(*(x,y),z) -> *(x,*(y,z)),*(x,+(y,z)) -> +(*(x,y),*(x,z)),app(nil,l) -> l,app(cons(x,l1),l2) -> cons(x,app(l1,l2)),sum(nil) -> 0(#),sum(cons(x,l)) -> +(x,sum(l)),sum(app(l1,l2)) -> +(sum(l1),sum(l2)),prod(nil) -> 1(#),prod(cons(x,l)) -> *(x,prod(l)),prod(app(l1,l2)) -> *(prod(l1),prod(l2)),mem(x,nil) -> false,mem(x,cons(y,l)) -> if(eq(x,y),true,mem(x,l)),inter(x,nil) -> nil,inter(nil,x) -> nil,inter(app(l1,l2),l3) -> app(inter(l1,l3),inter(l2,l3)),inter(l1,app(l2,l3)) -> app(inter(l1,l2),inter(l1,l3)),inter(cons(x,l1),l2) -> ifinter(mem(x,l2),x,l1,l2),inter(l1,cons(x,l2)) -> ifinter(mem(x,l1),x,l2,l1),ifinter(true,x,l1,l2) -> cons(x,inter(l1,l2)),ifinter(false,x,l1,l2) -> inter(l1,l2)], trsType = TRSContextSensitive, trsStrategy = Just FULL, signatureBlock = True}

++ File:".\\tests\\TPDB\\XML_version\\TRS_Standard\\CiME_04\\append.xml" :
TRS {trsSignature = fromList [("append",2),("cons",2),("false",0),("hd",1),("ifappend",3),("is_empty",1),("nil",0),("tl",1),("true",0)], trsVariables = fromList ["l","l1","l2","x"], trsRMap = [], trsRules = [is_empty(nil) -> true,is_empty(cons(x,l)) -> false,hd(cons(x,l)) -> x,tl(cons(x,l)) -> l,append(l1,l2) -> ifappend(l1,l2,l1),ifappend(l1,l2,nil) -> l2,ifappend(l1,l2,cons(x,l)) -> cons(x,append(l,l2))], trsType = TRSContextSensitive, trsStrategy = Just FULL, signatureBlock = True}

++ File:".\\tests\\TPDB\\XML_version\\TRS_Standard\\CiME_04\\append-wrong.xml" :
TRS {trsSignature = fromList [("append",2),("cons",2),("false",0),("hd",1),("ifappend",3),("is_empty",1),("nil",0),("tl",1),("true",0)], trsVariables = fromList ["l","l1","l2","x"], trsRMap = [], trsRules = [is_empty(nil) -> true,is_empty(cons(x,l)) -> false,hd(cons(x,l)) -> x,tl(cons(x,l)) -> cons(x,l),append(l1,l2) -> ifappend(l1,l2,is_empty(l1)),ifappend(l1,l2,true) -> l2,ifappend(l1,l2,false) -> cons(hd(l1),append(tl(l1),l2))], trsType = TRSContextSensitive, trsStrategy = Just FULL, signatureBlock = True}

++ File:".\\tests\\TPDB\\XML_version\\TRS_Standard\\CiME_04\\append-hard.xml" :
TRS {trsSignature = fromList [("append",2),("cons",2),("false",0),("hd",1),("ifappend",3),("is_empty",1),("nil",0),("tl",1),("true",0)], trsVariables = fromList ["l","l1","l2","x"], trsRMap = [], trsRules = [is_empty(nil) -> true,is_empty(cons(x,l)) -> false,hd(cons(x,l)) -> x,tl(cons(x,l)) -> l,append(l1,l2) -> ifappend(l1,l2,is_empty(l1)),ifappend(l1,l2,true) -> l2,ifappend(l1,l2,false) -> cons(hd(l1),append(tl(l1),l2))], trsType = TRSContextSensitive, trsStrategy = Just FULL, signatureBlock = True}

++ File:".\\tests\\TPDB\\XML_version\\TRS_Standard\\CiME_04\\ack_prolog.xml" :
TRS {trsSignature = fromList [("0",0),("ack_in",2),("ack_out",1),("s",1),("u11",1),("u21",2),("u22",1)], trsVariables = fromList ["m","n"], trsRMap = [], trsRules = [ack_in(0,n) -> ack_out(s(n)),ack_in(s(m),0) -> u11(ack_in(m,s(0))),u11(ack_out(n)) -> ack_out(n),ack_in(s(m),s(n)) -> u21(ack_in(s(m),n),m),u21(ack_out(n),m) -> u22(ack_in(m,n)),u22(ack_out(n)) -> ack_out(n)], trsType = TRSContextSensitive, trsStrategy = Just FULL, signatureBlock = True}
